"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContourType = exports.Costing = void 0;
const axios_1 = require("axios");
const mapbox_gl_1 = require("mapbox-gl");
exports.Costing = {
    Walking: 'pedestrian',
    Bicycle: 'bicycle',
    Car: 'auto',
};
exports.ContourType = {
    Time: 'time',
    Distance: 'distance',
};
class Valhalla {
    constructor(map, url, contours) {
        this.contourSources = [];
        this.contourLayers = [];
        this.contourMaker = undefined;
        this.contours = [
            {
                time: 5,
                distance: 1,
                color: 'ff0000',
            },
            {
                time: 10,
                distance: 3,
                color: 'ffff00',
            },
            {
                time: 15,
                distance: 5,
                color: '0000ff',
            },
        ];
        this.map = map;
        this.url = url;
        if (contours) {
            this.contours = contours;
        }
    }
    clearFeatures() {
        if (this.contourLayers && this.contourLayers.length > 0) {
            this.contourLayers.forEach((id) => {
                var _a;
                (_a = this.map) === null || _a === void 0 ? void 0 : _a.removeLayer(id);
            });
            this.contourLayers = [];
        }
        if (this.contourSources && this.contourSources.length > 0) {
            this.contourSources.forEach((id) => {
                var _a;
                (_a = this.map) === null || _a === void 0 ? void 0 : _a.removeSource(id);
            });
            this.contourSources = [];
        }
        if (this.contourMaker) {
            this.contourMaker.remove();
            this.contourMaker = undefined;
        }
    }
    getIsochrone(lon, lat, contourType, costing, contours) {
        this.clearFeatures();
        let contourList = JSON.parse(JSON.stringify(this.contours));
        if (contours) {
            contourList = contours;
        }
        contourList.forEach((c) => {
            if (contourType === exports.ContourType.Time) {
                delete c.distance;
            }
            else {
                delete c.time;
            }
        });
        let unit = 'km';
        if (contourType === exports.ContourType.Time) {
            unit = 'min';
        }
        return new Promise((resolve, reject) => {
            const jsonOption = {
                locations: [{ lat, lon }],
                costing,
                contours: contourList,
                polygons: true,
            };
            const url = `${this.url}/isochrone?json=${JSON.stringify(jsonOption)}`;
            axios_1.default.get(url).then((res) => {
                const geojson = res.data;
                geojson.features.forEach((f) => {
                    var _a, _b, _c, _d;
                    const sourceName = `isochrone-${f.properties.contour}`;
                    (_a = this.map) === null || _a === void 0 ? void 0 : _a.addSource(sourceName, {
                        type: 'geojson',
                        data: f,
                    });
                    this.contourSources.push(sourceName);
                    (_b = this.map) === null || _b === void 0 ? void 0 : _b.addLayer({
                        id: `pg-${sourceName}`,
                        type: 'fill',
                        source: sourceName,
                        layout: {},
                        paint: {
                            'fill-color': f.properties.fillColor,
                            'fill-opacity': 0.1,
                        },
                    });
                    this.contourLayers.push(`pg-${sourceName}`);
                    (_c = this.map) === null || _c === void 0 ? void 0 : _c.addLayer({
                        id: `ls-${sourceName}`,
                        type: 'line',
                        source: sourceName,
                        layout: {
                            'line-join': 'round',
                            'line-cap': 'round',
                        },
                        paint: {
                            'line-color': f.properties.fillColor,
                            'line-width': 3,
                        },
                    });
                    this.contourLayers.push(`ls-${sourceName}`);
                    (_d = this.map) === null || _d === void 0 ? void 0 : _d.addLayer({
                        id: `symbol-${sourceName}`,
                        type: 'symbol',
                        source: sourceName,
                        layout: {
                            'symbol-placement': 'line',
                            'text-pitch-alignment': 'viewport',
                            'text-font': ['Roboto Bold'],
                            'text-field': ['concat', ['get', 'contour'], ` ${unit}`],
                            'text-size': 16,
                        },
                        paint: {
                            'text-color': '#000000',
                            'text-halo-width': 1,
                            'text-halo-color': '#FFFFFF',
                        },
                    });
                    this.contourLayers.push(`symbol-${sourceName}`);
                });
                if (this.map) {
                    this.contourMaker = new mapbox_gl_1.Marker().setLngLat([lon, lat]).addTo(this.map);
                }
                resolve();
            }).catch((err) => reject(err));
        });
    }
    getContoursOption() {
        return this.contours;
    }
}
exports.default = Valhalla;
//# sourceMappingURL=valhalla.js.map